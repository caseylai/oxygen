package oxygen.io;

/*
 * 实体数据访问处理模块技术规格说明书 version 1.0
 * 概述实体数据访问处理的实现目标和方法及技术规格。
 * 
 * 
 * 一、实体数据访问处理器的概念
 * 实体数据访问处理器是处理实体查询、插入、删除、修改等数据访问请求的最底层类，它直接操作I/O完成实体以及相关索引的数据操作。
 * 
 * 二、实体文件结构
 * 实体文件按utf-8编码，其中实体无序地线性排列。每一个单独的实体中，字段按有序的线性排列，并且所有的实体中字段的顺序都是字段名的升序。
 * 实体的定位是用在实体文件中的偏移量来决定的。另一个值得注意的是，实体有固定的大小，实体在实体文件中的开始偏移量只能是这个大小的非负整数倍。
 * 如一个实体的大小为200字节，那么，实体的偏移量只能是200字节的非负整数倍：0字节、200字节、400字节…… 
 * 仅靠实体在实体文件中的偏移量还不能决定某一实体某个字段在实体文件中的位置，还需要确定实体中字段的偏移量。由于实体中的字段是有序的，
 * 而且字段也有其固定的最大大小（字符串的这个大小由标注SizeConstraint决定，数值字段由本身的字节长度决定，布尔字段固定为1），
 * 所以实体中字段的偏移量可以确定。可以通过LookupTable的offset()方法来获得某一字段在实体中的偏移量。
 * 实体大小等于实体中所有字段最大大小的和。有了两个偏移量，实体中字段在实体文件中的偏移量就可以确定了。它等于两个偏移量之和。
 * 另外，需要说明的是，实体文件中实体的空间总是按实体的大小来分配的，而实体中字段是按字段的偏移量来分配的。
 * 即使字段的使用大小没有达到字段的最大大小，剩余的空间也将保留，不会被其他实体或字段所使用。若实体文件中存储了一定的实体后，
 * 希望修改实体的大小（即其中字段的大小，增大或减小）。必须正常退出数据库后，运行数据库的重构程序对实体文件进行重构。
 * 
 * 
 * 三、实体的存取
 * 实体的存取是通过实体数据访问处理器Handler的子类QueryHandler、InsertHandler、DeleteHandler、UpdateHandler来完成的。
 * 而某一类实体的存取操作是由Handler子类的参数类型所完成的。如实体User的存取由QueryHandler<User>、InsertHandler<User>、
 * DeleteHandler<User>、UpdateHandler<User>完成，分别完成其查询、插入、删除和修改操作。由于这四个处理器都操作一个实体文件，
 * 所以这些操作应该互斥地完成。当一次存取操作失败时，需要返回null或Boolean.FALSE表示失败外，在日志文件中记录错误信息。另外需要
 * 将存取失败对文件产生的中间状态消除，回滚到存取前的状态。
 * 
 * 1、初始化
 * 进行实体文件存取文件之前的初始化工作由查找表的构造器完成。初始化主要工作是：
 * 1) 打开/创建实体数据文件；
 * 2) 分析实体字段，确定字段在文件中的偏移量；
 * 3) 加载空位集合文件data/[实体名].fre。此文件记录了实体数据文件中的空白位置。
 * 
 * 2、查询
 * 实体查询处理器QueryHandler完成实体的查询工作。实体的查询需要一个实体作为查询条件。
 * 典型代码如下：
 * User user = EntityProvider.provide("User"); // User是一个实体。实例化一个User对象
 * user.name = "Susan"; // 名字为Susan的用户
 * user.address = "Beijing"; // 地址在Beijing的用户
 * Set<User> users = user.query(); // 得到名字为Susan、地址在Beijing的用户集合
 * 查询操作可以依靠索引提高性能。通过将作为条件查询的字段标注为索引，可以极大的提高查询速度。将实体标注为索引的方法是在字段前添加
 * "@Index"标注。但使用索引的缺点是增加插入、删除和修改操作的时间，因为更新实体需要维护索引的开销；并且索引会占用大量的内存和
 * 磁盘空间。1MB的磁盘空间能够容纳65536条索引，而在这个版本中，全部的索引都将读入到内存。
 * 查询操作的完整流程如下：
 * 首先分析查询条件。实体中不为null的字段和特殊处理null的字段均为查询条件。提取出这些字段的字段名和值，判断该字段是否是
 * 索引字段（带有@Index标注的字段是索引字段）。若字段不是索引字段，则求出该字段在实体中的偏移量（LookupTable的offset方法）
 * 和实体的大小（LookupTable的size方法）。这样可以从实体文件的每个实体中读取出该字段的内容并和查询条件实体的字段内容相比较，
 * 若内容相同，表名这是一个符合条件的实体，将其记录到一个集合中。但此种方法需要和实体文件中的每个实体一一比较，所以性能较差。
 * 若此字段是一个索引字段，则使用散列函数计算该查询条件字段内容的散列值，通过实体偏移量映射表直接得到符合条件的实体的偏移量集合。
 * 这种方法不需要磁盘I/O操作，性能非常好。若还有其他字段作为查询条件，则按同样方法查出符合条件的实体的偏移量集合……将所有集合取交集，
 * 得到的就是符合全部查询条件的集合，即查询结果集。然后将查询结果集中的偏移量位置的实体提取出来，放入Set中返回即可。
 * 另外，若数据库中含有多个完全相同的实体，查询操作将全部查到，但仅仅返回一个。关于这种情况的进一步解释，请参看下一部分”插入“。
 * 
 * 3、插入
 * 实体插入处理器InsertHandler完成实体的插入工作。实体的插入需要一个实体参数。
 * 典型代码如下：
 * User user = EntityProvider.provide("User"); // 获取一个待插入的实体实例
 * user.name = "Susan"; // 字段赋值
 * user.password = "mypassword"; // 字段赋值
 * ... // 字段赋值
 * user.address = "Beijing"; // 字段赋值
 * if ( user.insert() ) {
 *     System.out.println("successful"); // 返回true，表示插入成功。
 * } else {
 *     System.out.println("failed"); // 返回false，表示插入失败。错误信息保存于日志中。
 * }
 * 需要注意的是：在这个版本中，插入操作不对实体进行唯一性检查，所以允许插入多个完全相同的实体。但是，由于实体修改了Object的
 * equals()、hashCode()方法，所以多个字段值完全相同的实体将被作为一个实体返回。即“完全相同的实体只能查询出一个”。
 * 插入操作的完整流程如下：
 * 首先寻找实体文件中的空位。和索引文件中的空位来源相同，实体文件中的空位也是因为实体的删除而产生的。空位集合freeSet放置在该实体
 * 的查找表table中，此队列已作同步处理。若空位集合不为空，那么取出一个空位地址，并将队列中这个地址移除；将实体字段按偏移量顺序写入
 * 实体文件。若某个字段的值为null，则在实体文件中，该字段所占的位置全部以"\u0000"表示。若空位集合为空，表示实体文件中没有空位，
 * 则将实体记录到文件末尾。
 * 在实体写入到实体文件后，还要在索引文件中插入索引：首先将该实体的索引字段统计出来，这些字段将被插入到索引；然后使用
 * IndexManager的insert方法即可将该字段插入到索引中。若索引插入失败，错误信息将被记录入日志。有关索引更详细的信息，
 * 可以参看IndexManager中的”索引管理模块技术规格说明书“。
 * 
 * 4、删除
 * 实体删除处理器DeleteHandler完成实体的删除工作。实体的删除需要一个实体参数。同实体的查询相似，这个实体也作为查询条件，
 * 但查询到的实体将全部被删除。
 * 典型代码如下：
 * User user = EntityProvider.provide("User"); // 获取一个待删除的实体实例
 * user.name = "Susan"; // 名字为Susan的用户
 * user.address = "Beijing"; // 地址在Beijing的用户
 * if ( user.delete() ) { // 删除名字为Susan、且地址在Beijing的用户
 *     System.out.println("successful"); // 返回true，表示删除成功。
 * } else {
 *     System.out.println("failed"); // 返回false，表示删除失败。错误信息保存于日志中。
 * }
 * 删除操作的完整流程如下：
 * 首先查询实体参数，但不和查询操作一样返回实体集合，而是返回实体的偏移量集合；然后依次将这些偏移量对应的实体用"\u0000"覆盖。
 * 删除成功完成后，将删除实体的偏移量记录入查找表的空位集合中。在实体文件的实体被删除后，还要将索引文件中的该实体的索引删除。
 * 首先将该实体中全部的索引字段统计出来（包括值为null的），然后调用IndexManager的delete方法将这些索引字段上值为被删除偏移量的索引
 * 全部删除。若索引删除失败，错误信息将被记录入日志。有关索引更详细的信息，可以参看IndexManager中的”索引管理模块技术规格说明书“。
 * 
 * 5、修改
 * 实体修改处理器UpdateHandler完成实体的修改工作。实体的修改需要相同类型的两个实体参数。第一个实体参数将作为查询条件，
 * 即修改操作的实体目标。第二个实体参数所有不为null的字段是待修改的字段，即把查询出来的实体目标的相应字段以第二个实体参数不为null
 * 的字段的内容替换掉。
 * 典型代码如下：
 * User user1 = EntityProvider.provide("User"); // 获得一个实体实例。这个实体将被作为查询条件，也是修改操作的目标实体。
 * User user2 = EntityProvider.provide("User"); // 另外获得一个实体实例。这个实体中不为null的字段是要替换的字段，且
 * 替换内容是这些字段的值。
 * user1.name = "Susan"; // (*)
 * user2.name = "Julie"; // (**)
 * if ( user1.update(user2) ) { // 以上三条语句表示”将名字为Susan的用户的名字修改为Julie“ 
 *     System.out.println("successful"); // 返回true，表示修改成功。
 * } else {
 *     System.out.println("failed"); // 返回false，表示修改失败。错误信息保存于日志中。
 * }
 * 若上面标示"**"号的语句修改为：
 * user2.address = "Shenzhen";
 * 那么，这个修改表示将名字为Susan的用户的地址修改为Shenzhen。
 * 若需要将字段修改为null，那么需要调用setSpecialNull方法，还是以上面的代码为例，把所有名字叫Susan的用户的名字清除为null：
 * 修改上面标示为"*"的语句为:
 * user1.setSpecialNull( "name" );
 * 而不能使用：
 * user1.name = null;
 * 使用这种错误的情况会引起修改的泛化：很多不期望被修改的实体也将被修改。因为null是不作为查询条件的。
 * 修改操作的完整流程如下：
 * 首先查询第一个实体参数，但不和查询操作一样返回实体集合，而是返回实体的偏移量集合；然后提取出第二个实体参数中不为null的字段名
 * 和字段内容。然后，在实体文件中依次修改查询到偏移量的实体，将其字段修改为第二个实体参数对应字段的内容。在实体文件中修改完成后，
 * 还要更新索引。如果第二个实体参数不为null的字段也是索引字段的话，调用IndexManager的update方法即可实现该索引字段的更新，
 * 它将被修改实体的索引字段重新散列，并写入索引文件中。若索引修改失败，错误信息将被记录入日志。有关索引更详细的信息，
 * 可以参看IndexManager中的”索引管理模块技术规格说明书“。
 * 
 * 
 * 四、回滚技术
 * 由于一个实体的存取操作涉及到索引（可能不止一个）的存取操作，当中间发生失败时如何保证操作的完整性？例如，当实体已插入到实体
 * 文件，但由于某种原因，该实体的第二条索引插入失败。若直接返回失败的话，错误将遗留在实体文件当中。因此，必须对这种情况进行
 * 处理。
 * 处理方法是使用回滚技术：即记录实体操作中的文件操作，当操作中间失败时，在返回失败之前，首先对文件修改进行还原，还原到操作
 * 之前的状态。再清除内存中的状态，返回失败，这样实体操作的完整性可以得到保证。
 * 回滚技术的实现：
 * 一个实体的存取通常不是单独进行的，一般还涉及索引的操作。一个完整的实体操作过程包括实体文件的存取和与其相关的索引的存取，
 * 实体操作成功必须其索引的操作也是成功的。这样，可以将实体操作和索引操作看作事务，由于这个事务处于实体操作的内部，所以称为
 * “微事务”。一个实体的插入、删除和修改都会启动一个微事务，每当有文件（实体文件或索引文件）写入操作（插入、删除、修改）时，
 * 都会往微事务的回滚队列中添加一个可以恢复文件修改的回滚类实例，当后面某一步失败时，将执行回滚队列中回滚类的方法以将文件
 * 恢复到操作前的状态。回滚技术与下一部分的多线程讨论密切相关。
 * 
 * 
 * 五、多线程与保护实体
 * 为了实体操作的高效性使用了多线程，同时为了使用了保护实体的概念来消除多线程带来的不安全性。实体文件的通道是保存在
 * 查找表（LookupTable）中的（查找表和实体数据访问处理器结合使用，保存实体数据访问处理器处理实体文件的中间状态，关于查找表的
 * 详细说明请看查找表类），相同类型的实体总是由相同类型的处理器处理的，这些处理器使用的是唯一的、对应于实体文件的查找表，
 * 包括查找表中的文件通道。所以，在实体操作前，必须确保其多线程安全。使用查找表的lock方法可以将文件通道锁定，在使用unlock
 * 方法解锁前该通道只能由锁定的线程所使用（实际不是锁住通道，而是一个契约：使用查找表内文件通道前必须调用查找表的lock方法，
 * 而使用结束后必须调用unlock方法释放锁定。若通道正在被其他线程使用，那么调用lock方法的线程会被阻塞，直到通道被释放为止）。
 * 典型代码如下：
 * try {
 *     table.lock(); // 使用文件通道前先调用查找表的lock方法
 *     FileChannel channel = table.channel();
 *     ... // 使用channel的操作
 * } catch ( IOException e ) {
 *     ... // 处理IOException
 * } finally {
 *     table.unlock(); // 使用结束后调用查找表的unlock方法，必须放在finally块中以确保执行
 * }
 * 仅仅在文件通道使用的时候锁定通道可以提高文件通道的吞吐率，同时在等待磁盘I/O的时间里CPU可以完成其他线程的操作，很好地提高
 * 了性能。但是由此却带来了一个问题：在一个“微事务”（见上一部分“回滚技术”的相关介绍）里，当实体只完成实体文件部分的操作，
 * 还未完成索引操作时（即微事务没有结束时），由于实体文件锁定已经释放，其他线程可能会对实体文件中微操作尚未完成的实体进行
 * 修改，造成数据不一致。针对这个问题，加入了保护实体的概念：当实体的地址确定后，通道操作之前，应该对这个实体（实际是实体地址）
 * 申请保护，而微事务完成之后，解除该实体（实体地址）的保护。保护期间，任何线程不能对该地址的实体进行任何操作（包括查询）。
 * 保护实体被认为是不稳定的，微事务没有完成，实体操作可能会被回滚撤销。
 * 典型代码如下：
 * long address = ... // 得到实体操作的地址
 * table.protect( address ); // 保护该实体地址
 * channel.write( buffer, address ); //写实体文件
 * ... // 微事务
 * } finally {
 *     table.unprotect( address ); // 解除该实体地址的保护。放在finally块中确保执行
 * }
 * 索引操作中也使用到“保护”“索引微事务”的概念，请参看IndexManager中的”索引管理模块技术规格说明书“。
 */

import java.util.logging.Logger;

import oxygen.entity.Entity;
import oxygen.io.transaction.RollbackFileWriter;
import oxygen.util.i18n.ResourceLoader;
import oxygen.util.i18n.ResourceLoaderProvider;


/**
 * <p>实体数据访问处理器公共超类</p>
 * <p>实体数据访问处理器用于处理实体的查询、增加、删除、修改等数据访问请求。</p>
 * <p>这个类实现了Runnable接口。由于数据访问涉及磁盘I/O操作较多，实体数据访问处理器启用多线程将有利于性能的提高。</p>
 * <p>本处理器是操作安全的。若数据访问请求处理失败，将{@link Rollback 回滚}至操作前的状态并返回失败标志。</p>
 * @see Entity 实体
 * @see QueryHandler 实体查询处理器
 * @see InsertHandler 实体插入处理器
 * @see DeleteHandler 实体删除处理器
 * @see UpdateHandler 实体修改处理器
 * @see Transaction 事务
 * @author 赖昆
 * @since 1.0, 2006-12-28
 * @version 1.0
 * @param <E> 实体
 */
public abstract class Handler<E extends Entity<E>> implements Runnable {
	
	// 实体查找表
	protected final LookupTable<E> table;
	
	// 微事务
	protected final MicroTransaction transaction = new MicroTransaction();
	
	// 事务的回滚文件记录器
	protected final RollbackFileWriter writer;
	
	protected static final Logger logger = Logger.getLogger( Handler.class.getName() );
	
	protected static final ResourceLoader res = ResourceLoaderProvider.provide( Handler.class );
	
	Handler( LookupTable<E> table, RollbackFileWriter writer ) {
		this.table = table;
		this.writer = writer;
	}
	
	// 对数据访问请求进行处理
	abstract void handle();

	public void run() {
		try {
			table.use();
			handle();
		} finally {
			table.away();
		}
	}
}
